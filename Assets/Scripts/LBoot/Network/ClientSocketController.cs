//
// NetworkThread.cs
//
// Author:
//       duwenjie
//

//
// ------------------------------------------------------------------------------
//  <autogenerated>
//      This code was generated by a tool.
//      Mono Runtime Version: 4.0.30319.1
// 
//      Changes to this file may cause incorrect behavior and will be lost if 
//      the code is regenerated.
//  </autogenerated>
// ------------------------------------------------------------------------------
using System;
using UnityThreading;
using SLua;

namespace LBoot
{
    public class ClientSocketController : IDisposable
    {
        public static int TICK_MS = 100;
        
        public static int INIT_BUF_SIZE = 8 * 1024;
        public static int HIGH_BUF_SIZE = 64 * 1024;

        protected TickThread netThread;
        protected Dispatcher netThreadDispatcher;

        protected ClientSocket client;
        protected byte [] buffer = new byte[INIT_BUF_SIZE];
        protected LightLuaEnv lua;

        public delegate void OnReceivePacket(LuaTable packet);

        public ClientSocketController(string host, int port, bool updatedScript)
            : this (new ClientSocket(host, port), updatedScript)
        {
        }

        public ClientSocketController(ClientSocket client, bool updatedScript) 
        {
            this.client = client;
            this.lua = new LightLuaEnv("cl_unity.lc", updatedScript);

            netThread = new TickThread(() => {
                netThreadDispatcher = new Dispatcher();
                netThreadDispatcher.ProcessTasks();
            }, TICK_MS, true);
        }

        public void Dispose()
        {
            Abort();
        }

        public void Abort()
        {
            if (netThread != null)
            {
                netThread.Abort();
                netThread = null;
            }
        }

        public void Connect(ClientSocket.OnConnect onConnect, OnReceivePacket onReceivePacket)
        {
            netThreadDispatcher.Dispatch(() => {
                client.AsyncConnect((bool success) => {
                    if (success)
                    {
                        StartReceive(onReceivePacket);
                    }
                    Dispatcher.Main.Dispatch(() => {
                        onConnect.Invoke(success);
                    });
                });
            });
        }

        public void Close()
        {
            netThreadDispatcher.Dispatch(() => {
                client.Close();
            });
        }

        internal void StartReceive(OnReceivePacket onReceivePacket)
        {
            netThreadDispatcher.Dispatch(() => {
                client.AsyncReceive(buffer, (byte [] data, int bytesReceived) => {
                    int offset = 0;
                    LuaTable packet = parseDecode(data, out offset);
                    while (packet != null)
                    {
                        Dispatcher.Main.Dispatch(() => {
                            onReceivePacket(packet);
                        });
                        packet = parseDecode(data, out offset);
                    }

                    if (offset > 0)
                    {
                        int remainBytes = bytesReceived - offset;
                        if (data.Length > HIGH_BUF_SIZE)
                        {
                            // shrink buffer, keep mem usage down
                            buffer = new byte[remainBytes > INIT_BUF_SIZE ? remainBytes : INIT_BUF_SIZE];
                        }
                        // consume bytes
                        Buffer.BlockCopy(data, offset, buffer, 0, remainBytes);
                    }
                    else if (bytesReceived == data.Length)
                    {
                        // expand buffer
                        buffer = new byte[bytesReceived * 2];
                        Buffer.BlockCopy(data, 0, buffer, 0, bytesReceived);
                    }

                    StartReceive(onReceivePacket);
                });
            });
        }

        public void Send(LuaTable packet, ClientSocket.OnSend onSend)
        {
            netThreadDispatcher.Dispatch(() => {
                byte [] data = generateEncode(packet);
                client.AsyncSend(data, (int bytesSent) => {
                    Dispatcher.Main.Dispatch(() => {
                        onSend(bytesSent);
                    });
                });
            });
        }

        public byte [] generateEncode(LuaTable packet)
        {
            return null;
        }

        public LuaTable parseDecode(byte [] data, out int offset)
        {
            offset = 0;
            return null;
        }
    }
}

