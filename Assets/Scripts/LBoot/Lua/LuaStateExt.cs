//
// LuaStateExt.cs
//
// Author:
//       duwenjie
//

//
// ------------------------------------------------------------------------------
//  <autogenerated>
//      This code was generated by a tool.
//      Mono Runtime Version: 4.0.30319.1
// 
//      Changes to this file may cause incorrect behavior and will be lost if 
//      the code is regenerated.
//  </autogenerated>
// ------------------------------------------------------------------------------
using System;
using UnityEngine;
using LuaInterface;
using LBoot;


namespace SLua
{
    public class LuaStateExt
    {
        public IntPtr L;
        private LuaCSFunction errorFunc = LuaState.errorFunc;

        public LuaStateExt(LuaState luaState)
        {
            this.L = luaState.L;
        }

        public bool doDeflatedBuffer(byte[] bytes, string fn, out object ret)
        {
            ret = null;
            LuaDLL.lua_pushcfunction(L, errorFunc);
            int errfunc = LuaDLL.lua_gettop(L);
            if (LuaDLL.lz_loadbuffer_deflated(L, bytes, bytes.Length, fn) == 0)
            {
                if (LuaDLL.lua_pcall(L, 0, LuaDLL.LUA_MULTRET, -2) != 0)
                {
                    LuaDLL.lua_pop(L, 1);
                    return false;
                }
                LuaDLL.lua_remove(L, errfunc); // pop error function
                ret = topObjects(errfunc - 1);
                return true;
            }
            string err = LuaDLL.lua_tostring(L, -1);
            LogUtil.Error(err);
            LuaDLL.lua_pop(L, 1);
            return false;
        }

        public bool doArc4Buffer(byte[] bytes, string fn, byte [] key, out object ret)
        {
            ret = null;
            LuaDLL.lua_pushcfunction(L, errorFunc);
            int errfunc = LuaDLL.lua_gettop(L);
            if (LuaDLL.lz_loadbuffer_arc4(L, bytes, bytes.Length, key, key.Length, fn) == 0)
            {
                if (LuaDLL.lua_pcall(L, 0, LuaDLL.LUA_MULTRET, -2) != 0)
                {
                    LuaDLL.lua_pop(L, 1);
                    return false;
                }
                LuaDLL.lua_remove(L, errfunc); // pop error function
                ret = topObjects(errfunc - 1);
                return true;
            }
            string err = LuaDLL.lua_tostring(L, -1);
            LogUtil.Error(err);
            LuaDLL.lua_pop(L, 1);
            return false;
        }

        public bool doAesBuffer(byte[] bytes, string fn, byte [] key, byte [] iv, out object ret)
        {
            ret = null;
            LuaDLL.lua_pushcfunction(L, errorFunc);
            int errfunc = LuaDLL.lua_gettop(L);
            byte[] temp = new byte[iv.Length];
            Array.Copy(iv, temp, iv.Length);
            if (LuaDLL.lz_loadbuffer_aes(L, bytes, bytes.Length, key, key.Length, temp, temp.Length, fn) == 0)
            {
                if (LuaDLL.lua_pcall(L, 0, LuaDLL.LUA_MULTRET, -2) != 0)
                {
                    LuaDLL.lua_pop(L, 1);
                    return false;
                }
                LuaDLL.lua_remove(L, errfunc); // pop error function
                ret = topObjects(errfunc - 1);
                return true;
            }
            string err = LuaDLL.lua_tostring(L, -1);
            LogUtil.Error(err);
            LuaDLL.lua_pop(L, 1);
            return false;
        }

        internal object topObjects(int from)
        {
            int top = LuaDLL.lua_gettop(L);
            int nArgs = top - from;
            if (nArgs == 0)
                return null;
            else if (nArgs == 1)
            {
                object o = LuaObject.checkVar(L, top);
                LuaDLL.lua_pop(L, 1);
                return o;
            }
            else
            {
                object[] o = new object[nArgs];
                for (int n = 1; n <= nArgs; n++)
                {
                    o[n - 1] = LuaObject.checkVar(L, from + n);
                    
                }
                LuaDLL.lua_settop(L, from);
                return o;
            }
        }

    }
}

