//
// LuaBridge.cs
//
// Author:
//       duwenjie
//

//
// ------------------------------------------------------------------------------
//  <autogenerated>
//      This code was generated by a tool.
//      Mono Runtime Version: 4.0.30319.1
//
//      Changes to this file may cause incorrect behavior and will be lost if
//      the code is regenerated.
//  </autogenerated>
// ------------------------------------------------------------------------------

// #define PROFILE_FILE

using UnityEngine;
using System.Threading;
using LuaInterface;
using SLua;
using System;
using System.IO;
using System.Reflection;
using System.Collections;
using System.Collections.Generic;

namespace LBoot
{
	public class LuaBridge
	{
		public LuaState luaState;
		public LuaStateExt luaStateExt;
		static LuaSvrGameObject lgo;
		int errorReported = 0;
		public bool inited = false;

		public LuaBridge()
		{
			GameObject go = new GameObject("LuaSvrProxy");
			lgo = go.AddComponent<LuaSvrGameObject>();
			GameObject.DontDestroyOnLoad(go);
		}

		public IEnumerator waitForDebugConnection(Action complete)
		{
			lgo.skipDebugger = false;
			LogUtil.Debug("Waiting for debug connection");
			while (true) {
				yield return new WaitForSeconds(0.1f);
				if (lgo.skipDebugger)
					break;
			}
			complete();
		}

		private volatile int bindProgress = 0;

		private void doBind(object state)
		{
			IntPtr L = (IntPtr)state;

			Assembly[] ams = AppDomain.CurrentDomain.GetAssemblies();

			bindProgress = 0;

			List<Type> bindlist = new List<Type>();
			for (int n = 0; n < ams.Length;n++ )
			{
				Assembly a = ams[n];
				Type[] ts = null;
				try
				{
					ts = a.GetExportedTypes();
				}
				catch
				{
					continue;
				}
				for (int k = 0; k < ts.Length; k++)
				{
					Type t = ts[k];
					if (t.GetCustomAttributes(typeof(LuaBinderAttribute), false).Length > 0)
					{
						bindlist.Add(t);
					}
				}
			}

			bindProgress = 1;

			bindlist.Sort(new System.Comparison<Type>((Type a, Type b) => {
				LuaBinderAttribute la = (LuaBinderAttribute)a.GetCustomAttributes(typeof(LuaBinderAttribute), false)[0];
				LuaBinderAttribute lb = (LuaBinderAttribute)b.GetCustomAttributes(typeof(LuaBinderAttribute), false)[0];

				return la.order.CompareTo(lb.order);
			}));

			List<Action<IntPtr>> list = new List<Action<IntPtr>>();
			for (int n = 0; n < bindlist.Count; n++)
			{
				Type t = bindlist[n];
				var sublist = (Action<IntPtr>[])t.GetMethod("GetBindList").Invoke(null, null);
				list.AddRange(sublist);
			}

			bindProgress = 2;

			int count = list.Count;
            try {
    			for (int n = 0; n < count; n++)
    			{
    				Action<IntPtr> action = list[n];
    				action(L);
    				bindProgress = (int)(((float)n / count) * 98.0) + 2;
    			}
            } catch (Exception e) {
                LogUtil.Error(e.ToString());
            }

			bindProgress = 100;
		}

		public IEnumerator waitForBind(Action<int> tick, Action complete)
		{
			int lastProgress = 0;
			do {
				if (tick != null)
					tick(bindProgress);
				// too many yield return will increase binding time
				// so check progress and skip odd progress
				if (lastProgress != bindProgress && bindProgress % 2 == 0) {
					lastProgress = bindProgress;
					yield return null;
				}
			} while (bindProgress != 100);

			if (tick != null)
				tick(bindProgress);

			complete();
		}

		void doinit(IntPtr L)
		{
			// LuaTimer.reg(L);
			LuaCoroutine.reg(L, lgo);
			Helper.reg(L);
			LuaValueType.reg(L);
			SLuaDebug.reg(L);
			LuaUtils.reg(luaState.L);

			lgo.state = luaState;
			lgo.onUpdate = this.tick;
			lgo.init();

			LuaState.errorDelegate = delegate(string msg) {
				errorDelegate(msg);
			};

			inited = true;
		}

		void errorDelegate(string msg)
		{
			this.luaState.OneLevelCall ("RECORD_LOGS", msg, true);
		}

        public void initSync()
        {
            LuaState luaState = new LuaState();
            luaStateExt = new LuaStateExt(luaState);
            LuaDLL.open_luaext(luaState.L);
            LuaDLL.lua_settop(luaState.L, 0);

            IntPtr L = luaState.L;
            LuaObject.init(L);
            doBind(L);
            this.luaState = luaState;
            doinit(L);
            checkTop(L);
        }

		public void init(Action<int> tick, Action complete, bool debug = false)
		{
			LuaState luaState = new LuaState();
			luaStateExt = new LuaStateExt(luaState);
			LuaDLL.open_luaext(luaState.L);
			LuaDLL.lua_settop(luaState.L, 0);

			IntPtr L = luaState.L;
			LuaObject.init(L);

			ThreadPool.QueueUserWorkItem(doBind, L);

			lgo.StartCoroutine(waitForBind(tick, () => {
				this.luaState = luaState;
				doinit(L);
				if (debug) {
					lgo.StartCoroutine(waitForDebugConnection(() => {
						complete();
						checkTop(L);
					}));
				} else {
					complete();
					checkTop(L);
				}
			}));
		}

		void checkTop(IntPtr L)
		{
			if (LuaDLL.lua_gettop(luaState.L) != errorReported) {
				LogUtil.Error("Some function not remove temp value from lua stack. You should fix it.");
				errorReported = LuaDLL.lua_gettop(luaState.L);
			}
		}

		void tick()
		{
			if (!inited)
				return;

#if PROFILE_FILE
            UnityEngine.Profiler.BeginSample("LuaBridge.tick 1");
#endif
			if (LuaDLL.lua_gettop(luaState.L) != errorReported) {
				errorReported = LuaDLL.lua_gettop(luaState.L);
				LogUtil.Error(string.Format("Some function not remove temp value({0}) from lua stack. You should fix it.", LuaDLL.luaL_typename(luaState.L, errorReported)));
			}

			luaState.checkRef();
#if PROFILE_FILE
			UnityEngine.Profiler.EndSample();
#endif

#if PROFILE_FILE
			// UnityEngine.Profiler.BeginSample("LuaBridge.tick 2");
#endif
			// LuaTimer.tick(Time.deltaTime);
#if PROFILE_FILE
			// UnityEngine.Profiler.EndSample();
#endif
		}

		public IntPtr handle {
			get {
				return luaState.handle;
			}
		}

		public void Dispose()
		{
			Dispose(true);
			System.GC.Collect();
			System.GC.WaitForPendingFinalizers();
		}

		public virtual void Dispose(bool dispose)
		{
			if (dispose)
			{
				// Let lua state dispose itself, after all lua users are disposed.
				// if (luaState != null)
				// {
				// 	luaState.Dispose();
				// }
			}
		}

        public void Clean()
        {
            GameObject.DestroyImmediate(lgo.gameObject);
        }

		public object DoString(string fn)
		{
			return luaState.doString(fn);
		}

		public object DoString(string fn, string name)
		{
			return luaState.doString(fn, name);
		}

		public object DoBuffer(byte[] buf, string name)
		{
			if (buf == null) {
				LogUtil.Error("doBuffer called with null buffer! " + name);
				return null;
			}

			object ret;
			var ok = luaState.doBuffer(buf, name, out ret);
			if (!ok) {
				LogUtil.Error("doBuffer failed! " + name);
			}
			return ret;
		}

		public object DoDeflatedBuffer(byte[] buf, string name)
		{
			if (buf == null) {
				LogUtil.Error("doDeflatedBuffer called with null buffer!" + name);
				return null;
			}

			object ret;
			var ok = luaStateExt.doDeflatedBuffer(buf, name, out ret);
			if (!ok) {
				LogUtil.Error("doDeflatedBuffer failed! " + name);
			}
			return ret;
		}

		public object DoArc4Buffer(byte[] buf, string name, byte[] key)
		{
			if (buf == null) {
				LogUtil.Error("doArc4Buffer called with null buffer!" + name);
				return null;
			}

			object ret;
			var ok = luaStateExt.doArc4Buffer(buf, name, key, out ret);
			if (!ok) {
				LogUtil.Error("doArc4Buffer failed! " + name);
			}
			return ret;
		}

		public object DoAesBuffer(byte[] buf, string name, byte[] key, byte[] iv)
		{
			if (buf == null) {
				LogUtil.Error("doAesBuffer called with null buffer!" + name);
				return null;
			}

			object ret;
			var ok = luaStateExt.doAesBuffer(buf, name, key, iv, out ret);
			if (!ok) {
				LogUtil.Error("doAesBuffer failed! " + name);
			}
			return ret;
		}

		public object Call(string func, params object[] args)
		{
            if(luaState != null)
    			return luaState.Call(func, args);
            
            return null;
		}

		public object this [string path] {
			get {
				return luaState.getObject(path);
			}
			set {
				luaState.setObject(path, value);
			}
		}

		public LuaFunction GetFunction(string fn)
		{
			return luaState.getFunction(fn);
		}

		private static HashSet<string> ms_includedFiles = new HashSet<string>();

		[MonoPInvokeCallbackAttribute(typeof(LuaCSFunction))]
		internal static int import(IntPtr l)
		{

			LuaDLL.luaL_checktype(l, 1, LuaTypes.LUA_TSTRING);
			string str = LuaDLL.lua_tostring(l, 1);
			if (ms_includedFiles.Contains(str)) {
				return 0;
			} else {
				ms_includedFiles.Add(str);
			}
			return LuaState.import(l);

		}

	}
}

