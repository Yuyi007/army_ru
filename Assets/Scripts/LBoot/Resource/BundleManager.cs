//
// BundleCache.cs
//
// Author:
//       duwenjie
//
//
// ------------------------------------------------------------------------------
//  <autogenerated>
//      This code was generated by a tool.
//      Mono Runtime Version: 4.0.30319.1
//
//      Changes to this file may cause incorrect behavior and will be lost if
//      the code is regenerated.
//  </autogenerated>
// ------------------------------------------------------------------------------
using System;
using System.Collections.Generic;
using UnityEngine;
using System.Collections;
using SLua;
using System.Linq;

namespace LBoot
{
    [CustomLuaClassAttribute]
    public class AssetBundleRef
    {
        [SLua.DoNotToLuaAttribute]
        public AssetBundle assetBundle = null;

        private Dictionary<string, AssetBundleRequest> assetRequests = null;
        private Dictionary<string, bool> parentBundles = null;

        public AssetBundle AssetBundle
        {
            get
            {
                UpdateEndTime();
                return assetBundle;
            }
            set
            {
                UpdateEndTime();
                assetBundle = value;
            }
        }

        public void AddParentBundle(string parentBundlePath)
        {
            if (parentBundlePath == null)
                return;

            if (parentBundles == null)
            {
                parentBundles = new Dictionary<string, bool>();
            }
            parentBundles[parentBundlePath] = true;
        }


        public string uri;

        private double endTime;
        private int secondsToLive = -1;

        // -1 for literally infinite

        public int SecondsToLive
        {
            get
            {
                return secondsToLive;
            }
            set
            {
                secondsToLive = value;
                UpdateEndTime();
            }
        }

        public double EndTime
        {
            get
            {
                return endTime;
            }
        }

        public bool Dead
        {
            get
            {
                return Time.realtimeSinceStartup > endTime;
            }
        }

        public void UpdateEndTime()
        {
            if (secondsToLive > 0)
            {
                endTime = Time.realtimeSinceStartup + secondsToLive;
            }
            else
            {
                endTime = Time.realtimeSinceStartup + 99999999;
            }
        }

        public AssetBundleRef(string uri, int secondsToLive = -1)
        {
            this.uri = uri;
            this.secondsToLive = secondsToLive;
            UpdateEndTime();
        }

        public AssetBundleRequest LoadAssetAsync(string assetPath, Type t)
        {
            return LoadAssetAsync(assetPath);
        }

        public bool CanUnload()
        {
            if (assetRequests != null)
            {
                foreach (var pair in this.assetRequests)
                {
                    if (!pair.Value.isDone)
                        return false;
                }
            }

            if (parentBundles != null)
            {
                foreach (var pair in this.parentBundles)
                {
                    var parentBundlePath = pair.Key;
                    var parentBundle = BundleManager.GetBundleRef(parentBundlePath);
                    if (parentBundle != null && !parentBundle.CanUnload())
                    {
                        return false;
                    }
                }
            }
            return true;
        }

        [SLua.DoNotToLua]
        public void CleanUp()
        {
            if (assetRequests != null)
                assetRequests.Clear();
            if (parentBundles != null)
                parentBundles.Clear();

            this.assetRequests = null;
            this.parentBundles = null;
        }

        public void UnloadAsset(string assetPath)
        {
            if (assetRequests == null)
                return;

            AssetBundleRequest req = null;
            if (assetRequests.TryGetValue(assetPath, out req))
            {
                if (req.isDone)
                {
                    LogUtil.Trace("AssetBundleRef UnloadAsset:" + assetPath);
                    assetRequests.Remove(assetPath);
                    Resources.UnloadAsset(req.asset);
                }
            }
        }

        public AssetBundleRequest LoadAssetAsync(string assetPath)
        {
            var ab = this.AssetBundle;
            AssetBundleRequest req = null;
            if (assetRequests == null)
            {
                this.assetRequests = new Dictionary<string, AssetBundleRequest>();
            }

            this.assetRequests.TryGetValue(assetPath, out req);

            // when the req.isDone we should init a new request because:
            // the dependancy bundle might be unloaded and reloaded, and the reference
            // on the req.asset has changed.
            // we should init a new LoadAssetAsync request to get the asset with correct reference
            if (req == null || req.isDone)
            {
                req = ab.LoadAssetAsync(assetPath);
                this.assetRequests[assetPath] = req;
            }

            return req;
        }

        public UnityEngine.Object LoadAsset(string assetPath, Type t)
        {
            var ab = this.AssetBundle;
            return ab.LoadAsset(assetPath, t);
        }

        public UnityEngine.Object LoadAsset(string assetPath)
        {
            var ab = this.AssetBundle;
            return ab.LoadAsset(assetPath);
        }

        public UnityEngine.Object[] LoadAssetWithSubAssets(string assetPath)
        {
            var ab = this.AssetBundle;
            return ab.LoadAssetWithSubAssets(assetPath);
        }

        public AssetBundleRequest LoadAssetAsync<T>(string assetPath) where T : UnityEngine.Object
        {
            return LoadAssetAsync(assetPath);
        }

        public T LoadAsset<T>(string assetPath) where T : UnityEngine.Object
        {
            var ab = this.AssetBundle;
            return ab.LoadAsset<T>(assetPath);
        }


        public bool Contains(string assetPath)
        {
            var ab = this.AssetBundle;
            return ab.Contains(assetPath);
        }
    };

    [CustomLuaClassAttribute]
    public class AssetBundleLoadHistory
    {
        public string uri;
        public double[] loadTimes;
        public double[] unloadTimes;

        public void RecordLoad()
        {
            var thisTime = Time.realtimeSinceStartup;
            for (int i = 0; i < loadTimes.Length - 1; ++i)
            {
                loadTimes[i + 1] = loadTimes[i];
            }
            loadTimes[0] = thisTime;
        }

        public void RecordUnload()
        {
            var thisTime = Time.realtimeSinceStartup;
            for (int i = 0; i < unloadTimes.Length - 1; ++i)
            {
                unloadTimes[i + 1] = unloadTimes[i];
            }
            unloadTimes[0] = thisTime;
        }

        public void Clear()
        {
            for (int i = 0; i < loadTimes.Length; ++i)
            {
                loadTimes[i] = -1;
            }
            for (int i = 0; i < unloadTimes.Length; ++i)
            {
                unloadTimes[i] = -1;
            }
        }

        public AssetBundleLoadHistory(string uri)
        {
            this.uri = uri;
            this.loadTimes = new double[2];
            this.unloadTimes = new double[2];
            Clear();
        }
    };

    /// <summary>
    /// Keeping track of loaded bundles
    /// Reference: http://docs.unity3d.com/Manual/keepingtrackofloadedassetbundles.html
    /// </summary>
    [CustomLuaClassAttribute]
    public class BundleManager
    {
        public static bool loadWithWWW = false;
        public static int wwwVersion = 0;
        public static uint wwwCrc = 0;

        // A dictionary to hold the AssetBundle references
        static private Dictionary<string, AssetBundleRef> dictAssetBundleRefs;
        static private List<string> listAssetBundleUris;
        static private int curUnloadIndex;

        public static Dictionary<string, AssetBundleRef> DictAssetBundleRefs
        {
            get
            {
                return dictAssetBundleRefs;
            }
        }

        public static List<string> ListAssetBundleUris
        {
            get
            {
                return listAssetBundleUris;
            }
        }

        static private Dictionary<string, AssetBundleLoadHistory> dictAssetBundleLoadHistories;

        public static Dictionary<string, AssetBundleLoadHistory> DictAssetBundleLoadHistories
        {
            get
            {
                return dictAssetBundleLoadHistories;
            }
        }

        static private List<string> loadingBundles;
        static private List<string> tempUriList = new List<String>();

        static private BundleDependencies bundleDeps;
        static private Dictionary<string, int> ttlSettings;
        static private Dictionary<string, int> ttlPatternSettings;
        static private Dictionary<string, bool> noTTLSettings;

        static BundleManager()
        {
            dictAssetBundleRefs = new Dictionary<string, AssetBundleRef>();
            dictAssetBundleLoadHistories = new Dictionary<string, AssetBundleLoadHistory>();
            loadingBundles = new List<string>();
            listAssetBundleUris = new List<string>();
            curUnloadIndex = 0;
            ttlSettings = new Dictionary<string, int>();
            ttlPatternSettings = new Dictionary<string, int>();
            noTTLSettings = new Dictionary<string, bool>();

            var manifestFile = "bundles.bin";
            bundleDeps = new BundleDependencies(manifestFile);
        }

        public static void SetTTLSettings(string uri, int ttl)
        {
            var key = BundleHelper.fixBundleUri(uri);
            ttlSettings[key] = ttl;
        }

        public static void SetPatternTTLSettings(string key, int ttl)
        {
            ttlPatternSettings[key] = ttl;
        }

        [SLua.DoNotToLua]
        public static void GetTTLSettings(string path, ref int ttl)
        {
            if (ttlSettings.TryGetValue(path, out ttl))
            {
                LogUtil.Trace("GetTTLSettings:" + path + "=" + ttl.ToString());
                return;
            }

            if (noTTLSettings.ContainsKey(path))
            {
                return;
            }

            foreach (var pair in ttlPatternSettings)
            {
                var key = pair.Key;
                if (path.Contains(key))
                {
                    ttl = pair.Value;
                    SetTTLSettings(path, ttl);
                    LogUtil.Trace("GetTTLSettingsPattern:" + path + "=" + ttl.ToString());
                    return;
                }
            }

            LogUtil.Trace("[GetTTLSettings]" + path + " has no ttl settings");
            noTTLSettings[path] = true;
        }

        /// <summary>
        /// Set the bundle variants
        /// </summary>
        /// <param name="variants">Variants.</param>
        public static void SetBundleVariantes(string[] variants)
        {
            bundleDeps.SetVariants(variants);
        }

        public static string RemapVariantBundleName(string bundlePath)
        {
            return bundleDeps.RemapVariantName(bundlePath);
        }

        // Class with the AssetBundle reference, uri and version


        // Get an AssetBundle from cached bundles
        public static AssetBundle Get(string uri)
        {
            string keyName = GetBundleKey(uri);
            AssetBundleRef abRef;
            if (dictAssetBundleRefs.TryGetValue(keyName, out abRef))
            {
                return abRef.AssetBundle;
            }
            else
            {
                return null;
            }
        }

        public static AssetBundleRef GetBundleRef(string uri)
        {
            string keyName = GetBundleKey(uri);
            AssetBundleRef abRef;
            if (dictAssetBundleRefs.TryGetValue(keyName, out abRef))
            {
                return abRef;
            }
            else
            {
                return null;
            }
        }

        public static bool TryGetRefreshedBundleRef(string keyName, int ttl, out AssetBundleRef abRef)
        {
            if (dictAssetBundleRefs.TryGetValue(keyName, out abRef))
            {
                if (ttl < 0)
                {
                    abRef.SecondsToLive = ttl;
                }
                else
                {
                    abRef.UpdateEndTime();
                }
                return true;
            }

            return false;
        }

        // Get recent loaded AssetBundle load histories
        public static List<AssetBundleLoadHistory> GetRecentLoadHistories(double maxTimeDiff)
        {
            List<AssetBundleLoadHistory> histories = new List<AssetBundleLoadHistory>();
            foreach (KeyValuePair<string, AssetBundleLoadHistory> pair in dictAssetBundleLoadHistories)
            {
                var abLoadHistory = pair.Value;
                var time0 = abLoadHistory.loadTimes[0];
                var time1 = abLoadHistory.loadTimes[1];
                if (time0 > 0 && time1 > 0 && time0 - time1 < maxTimeDiff)
                {
                    histories.Add(abLoadHistory);
                }
            }
            return histories;
        }

        public static void ClearRecentLoadHistories(double maxTimeDiff)
        {
            foreach (KeyValuePair<string, AssetBundleLoadHistory> pair in dictAssetBundleLoadHistories)
            {
                var abLoadHistory = pair.Value;
                var time0 = abLoadHistory.loadTimes[0];
                var time1 = abLoadHistory.loadTimes[1];
                if (time0 > 0 && time1 > 0 && time0 - time1 < maxTimeDiff)
                {
                    abLoadHistory.Clear();
                }
            }
        }

        public static List<AssetBundleLoadHistory> GetLoadAfterUnloadHistories(double maxTimeDiff)
        {
            List<AssetBundleLoadHistory> histories = new List<AssetBundleLoadHistory>();
            foreach (KeyValuePair<string, AssetBundleLoadHistory> pair in dictAssetBundleLoadHistories)
            {
                var abLoadHistory = pair.Value;
                var timeLoad = abLoadHistory.loadTimes[0];
                var timeUnload = abLoadHistory.unloadTimes[0];
                if (timeLoad > 0 && timeUnload > 0 && timeLoad > timeUnload && timeLoad - timeUnload < maxTimeDiff)
                {
                    histories.Add(abLoadHistory);
                }
            }
            return histories;
        }

        // Get an AssetBundle load history
        public static AssetBundleLoadHistory GetLoadHistory(string uri)
        {
            string keyName = uri;
            AssetBundleLoadHistory abLoadHistory;
            if (dictAssetBundleLoadHistories.TryGetValue(keyName, out abLoadHistory))
            {
                return abLoadHistory;
            }
            else
            {
                return null;
            }
        }

        public static void ClearLoadHistory(string uri)
        {
            string keyName = uri;
            AssetBundleLoadHistory abLoadHistory;
            if (dictAssetBundleLoadHistories.TryGetValue(keyName, out abLoadHistory))
            {
                abLoadHistory.Clear();
            }
        }

        public static AssetBundleLoadHistory AddLoadHistory(string uri, bool isLoad)
        {
            string keyName = uri;
            AssetBundleLoadHistory abLoadHistory;

            if (dictAssetBundleLoadHistories.TryGetValue(keyName, out abLoadHistory))
            {
            }
            else
            {
                abLoadHistory = new AssetBundleLoadHistory(uri);
                dictAssetBundleLoadHistories.Add(keyName, abLoadHistory);
            }

            if (isLoad)
            {
                abLoadHistory.RecordLoad();
            }
            else
            {
                abLoadHistory.RecordUnload();
            }

            return abLoadHistory;
        }

        // Load an AssetBundle, without loading its dependencies
        public static AssetBundleRef Load(string uri, int ttl)
        {
            string keyName = GetBundleKey(uri);
            AssetBundleRef abRef;

            GetTTLSettings(uri, ref ttl);

            if (TryGetRefreshedBundleRef(keyName, ttl, out abRef))
            {
                loadingBundles.Remove(keyName);
                return abRef;
            }
            else
            {
                LogUtil.Trace("BundleManager: Load " + uri);
                AssetBundle bundle = null;

                if (loadWithWWW)
                {
                    bundle = BundleEncoder.CreateBundleFromWWW(uri, wwwVersion, wwwCrc);
                }
                else
                {
                    bundle = BundleEncoder.CreateBundleFromFile(uri);
                }

                if (bundle != null)
                {
                    abRef = new AssetBundleRef(uri, ttl);
                    abRef.AssetBundle = bundle;
                    dictAssetBundleRefs.Add(keyName, abRef);
                    listAssetBundleUris.Add(uri);
                    loadingBundles.Remove(keyName);
                    AddLoadHistory(uri, true);
                    return abRef;
                }
                else
                {
                    if (TryGetRefreshedBundleRef(keyName, ttl, out abRef))
                    {
                        loadingBundles.Remove(keyName);
                        return abRef;
                    }

                    LogUtil.Error("BundleManager: creating bundle from uri failed! " + uri);
                }

            }

            return null;
        }

        public static AssetBundleRef LoadWithDependencies(string uri, int ttl)
        {
            bundleDeps.LoadAllDependencies(uri, ttl);
            return Load(uri, ttl);
        }

        public static IEnumerator LoadWithDependenciesAsync(string uri, int ttl, Action<AssetBundleRef> onComplete)
        {
            var iter = LoadWithDependenciesAsync(uri, ttl);
            while (iter.MoveNext())
                yield return null;
            onComplete(GetBundleRef(uri));
        }

        public static IEnumerator LoadWithDependenciesAsync(string uri, int ttl)
        {
            var iter = bundleDeps.LoadAllDependenciesAsync(uri, ttl);
            while (iter.MoveNext())
                yield return null;
            iter = LoadAsync(null, uri, ttl);
            while (iter.MoveNext())
                yield return null;
        }

        internal static IEnumerator LoadAsync(string parentBundlePath, string uri, int ttl)
        {
            string keyName = GetBundleKey(uri);

            GetTTLSettings(uri, ref ttl);

            AssetBundleRef abRef;
            while (loadingBundles.Contains(keyName))
            {
                LogUtil.Trace("BundleManager: is already Loading " + keyName);
                yield return null;
            }

            if (TryGetRefreshedBundleRef(keyName, ttl, out abRef))
            {
                loadingBundles.Remove(keyName);
                abRef.AddParentBundle(parentBundlePath);
                yield break;
            }
            else
            {
                loadingBundles.Add(keyName);

                LogUtil.Trace("BundleManager: LoadAsyncWithNoCallback " + uri);
                AssetBundle bundle = null;

                if (loadWithWWW)
                {
                    var www = BundleEncoder.CreateBundleFromWWWAsync(uri, wwwVersion, wwwCrc);
                    while (!www.isDone)
                        yield return null;
                    if (www.error == null || www.error == "")
                    {
                        bundle = www.assetBundle;
                    }
                    else
                    {
                        LogUtil.Error("BundleManager: creating bundle from WWW failed: " + www.error);
                    }
                }
                else
                {
                    var req = BundleEncoder.CreateBundleFromFileAsync(uri);
                    while (!req.isDone && !TryGetRefreshedBundleRef(keyName, ttl, out abRef))
                        yield return null;

                    if (req.isDone)
                        bundle = req.assetBundle;
                }

                if (bundle != null)
                {
                    abRef = new AssetBundleRef(uri, ttl);
                    abRef.AssetBundle = bundle;
                    dictAssetBundleRefs.Add(keyName, abRef);
                    listAssetBundleUris.Add(uri);
                    AddLoadHistory(uri, true);
                    loadingBundles.Remove(keyName);
                    abRef.AddParentBundle(parentBundlePath);
                }
                else
                {
                    if (TryGetRefreshedBundleRef(keyName, ttl, out abRef))
                    {
                        loadingBundles.Remove(keyName);
                        abRef.AddParentBundle(parentBundlePath);
                    }
                    else
                    {
                        LogUtil.Error("BundleManager: creating bundle from uri failed! " + uri);
                    }
                }

                loadingBundles.Remove(keyName);
            }

        }

        public static IEnumerator LoadAsync(string uri, int ttl, Action<AssetBundleRef> onComplete)
        {
            var iter = LoadAsync(null, uri, ttl);
            while (iter.MoveNext())
                yield return null;

            onComplete(GetBundleRef(uri));
        }

        public static void Reset()
        {
            Reset(new string[0]);
        }

        public static void Reset(string[] unloads)
        {
            UnloadAll(false, unloads);
            loadingBundles.Clear();
            ttlSettings.Clear();
            ttlPatternSettings.Clear();
            noTTLSettings.Clear();
            bundleDeps.ReloadManifest();
        }

        // Unload an AssetBundle
        public static void Unload(string uri, bool unloadAllLoadedObjects)
        {
            string keyName = GetBundleKey(uri);
            AssetBundleRef abRef;
            if (dictAssetBundleRefs.TryGetValue(keyName, out abRef))
            {
                LogUtil.Trace("BundleManager: Unload " + uri);
                if (!abRef.CanUnload())
                {
                    LogUtil.Trace("loading asset async, cannot be unloaded " + uri);
                    return;
                }

                abRef.assetBundle.Unload(unloadAllLoadedObjects);
                abRef.assetBundle = null;
                abRef.CleanUp();
                dictAssetBundleRefs.Remove(keyName);
                listAssetBundleUris.Remove(uri);
                AddLoadHistory(uri, false);
            }
        }

        public static void UnloadAll(bool unloadAllLoadedObjects)
        {
            UnloadAll(unloadAllLoadedObjects, new string[0]);
        }

        public static void UnloadAll(bool unloadAllLoadedObjects, string[] unloads)
        {
            tempUriList.Clear();

            foreach (KeyValuePair<string, AssetBundleRef> pair in dictAssetBundleRefs)
            {
                var abRef = pair.Value;
                if (!unloads.Contains(abRef.uri))
                    tempUriList.Add(abRef.uri);
            }

            for (var i = 0; i < tempUriList.Count; ++i)
            {
                var uri = tempUriList[i];
                Unload(uri, unloadAllLoadedObjects);
            }

            for (var i = 0; i < unloads.Length; ++i)
            {
                var uri = unloads[i];
                Unload(uri, true);
            }

            tempUriList.Clear();
        }

        public static void UnloadDeadBundles()
        {
            UnloadDeadBundles(false);
        }

        public static void UnloadDeadBundles(bool unloadAllLoadedObjects)
        {
            tempUriList.Clear();

            foreach (KeyValuePair<string, AssetBundleRef> pair in dictAssetBundleRefs)
            {
                var abRef = pair.Value;
                if (abRef.Dead)
                {
                    tempUriList.Add(abRef.uri);
                }
            }

            for (var i = 0; i < tempUriList.Count; ++i)
            {
                var uri = tempUriList[i];
                // LogUtil.Trace("BundleManager: Unload dead bundle " + uri);
                Unload(uri, unloadAllLoadedObjects);
            }

            tempUriList.Clear();
        }

        private static string GetBundleKey(string uri)
        {
            var arr = uri.Split('.');
            return arr[0];
        }

        public static void UnloadDeadBundles(bool unloadAllLoadedObjects, int iterCount)
        {
            tempUriList.Clear();

            int i = 0;
            while (i < iterCount && curUnloadIndex < listAssetBundleUris.Count)
            {
                var keyName = GetBundleKey(listAssetBundleUris[curUnloadIndex]);
                AssetBundleRef abRef;
                if (dictAssetBundleRefs.TryGetValue(keyName, out abRef))
                {
                    if (abRef.Dead)
                    {
                        tempUriList.Add(abRef.uri);
                    }
                }
                else
                {
                    LogUtil.Error("BundleManager: iterate invalid keyName " + keyName);
                }
                ++i;
                ++curUnloadIndex;
                if (curUnloadIndex >= listAssetBundleUris.Count)
                {
                    curUnloadIndex = 0;
                }
            }

            if (curUnloadIndex >= listAssetBundleUris.Count)
            {
                curUnloadIndex = 0;
            }

            for (i = 0; i < tempUriList.Count; ++i)
            {
                var uri = tempUriList[i];
                LogUtil.Trace("BundleManager: Unload dead bundle " + uri);
                Unload(uri, unloadAllLoadedObjects);
            }

            tempUriList.Clear();
        }

        public static void UnloadDyingBundles(double period, bool unloadAllLoadedObjects)
        {
            tempUriList.Clear();

            var now = Time.realtimeSinceStartup;
            foreach (KeyValuePair<string, AssetBundleRef> pair in dictAssetBundleRefs)
            {
                var abRef = pair.Value;
                if (abRef.EndTime - now < period)
                {
                    tempUriList.Add(abRef.uri);
                }
            }

            for (var i = 0; i < tempUriList.Count; ++i)
            {
                var uri = tempUriList[i];
                LogUtil.Trace("BundleManager: Unload dying bundle " + uri + " period=" + period);
                Unload(uri, unloadAllLoadedObjects);
            }

            tempUriList.Clear();
        }

        public BundleDependencies GetBundleDependencies()
        {
            return bundleDeps;
        }

        public static string[] GetAllDependencies(string uri)
        {
            return bundleDeps.GetAllDependencies(uri);
        }

        public static void DumpAll()
        {
            LogUtil.Debug("BundleManager.DumpAll:");
            DumpBundleRefs();
            DumpBundleLoadHistories();
            DumpBundleLists();
        }

        public static void DumpBundleRefs()
        {
            LogUtil.Debug("---------------------------------------------------------");
            LogUtil.Debug("BundleRefs:");
            foreach (KeyValuePair<string, AssetBundleRef> pair in dictAssetBundleRefs)
            {
                var abRef = pair.Value;
                LogUtil.Debug("key=" + pair.Key +
                    " uri=" + abRef.uri +
                    " endTime=" + abRef.EndTime +
                    " secondsToLive=" + abRef.SecondsToLive);
            }
        }

        public static void DumpBundleLoadHistories()
        {
            LogUtil.Debug("---------------------------------------------------------");
            LogUtil.Debug("BundleLoadHistories:");
            foreach (KeyValuePair<string, AssetBundleLoadHistory> pair in dictAssetBundleLoadHistories)
            {
                var abLoadHistory = pair.Value;
                LogUtil.Debug("key=" + pair.Key +
                    " uri=" + abLoadHistory.uri +
                    " loadTimes=" + abLoadHistory.loadTimes +
                    " unloadTimes=" + abLoadHistory.unloadTimes);
            }
        }

        public static void DumpBundleLists()
        {
            LogUtil.Debug("---------------------------------------------------------");
            LogUtil.Debug("listAssetBundleUris:");
            foreach (string uri in listAssetBundleUris)
            {
                LogUtil.Debug("uri=" + uri);
            }

            LogUtil.Debug("---------------------------------------------------------");
            LogUtil.Debug("loadingBundles:");
            foreach (string uri in loadingBundles)
            {
                LogUtil.Debug("uri=" + uri);
            }

            LogUtil.Debug("---------------------------------------------------------");
            LogUtil.Debug("tempUriList:");
            foreach (string uri in tempUriList)
            {
                LogUtil.Debug("uri=" + uri);
            }

            LogUtil.Debug("curUnloadIndex=" + curUnloadIndex);
        }
    }
}

