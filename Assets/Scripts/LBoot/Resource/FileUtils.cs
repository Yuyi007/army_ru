//
// FileUtils.cs
//
// Author:
//       duwenjie
//

//
// ------------------------------------------------------------------------------
//  <autogenerated>
//      This code was generated by a tool.
//      Mono Runtime Version: 4.0.30319.1
//
//      Changes to this file may cause incorrect behavior and will be lost if
//      the code is regenerated.
//  </autogenerated>
// ------------------------------------------------------------------------------


// #define PROFILE_FILE

using System;
using System.IO;
using UnityEngine;
using SLua;
using System.Collections.Generic;
using System.IO.Compression;
using ICSharpCode.SharpZipLib.Core;
using ICSharpCode.SharpZipLib.Zip;

namespace LBoot
{
    /// <summary>
    /// FileUtils for providing a common interface for all platforms
    /// Also provides search paths abilities
    /// </summary>
    ///
    [CustomLuaClassAttribute]
    public class FileUtils
    {
        internal static string DEFAULT_SEARCH_PATH = "";

        // in the begining there is only one search path: an empty string
        internal static List<string> searchPaths = new List<string>{ DEFAULT_SEARCH_PATH };
        internal static string updatePath = null;
        internal static string bundleInitTag = "OK";

        public static string UpdatePath
        {
            get
            {
                if (updatePath == null)
                {
                    updatePath = Application.persistentDataPath + "/update";
                }
                return updatePath;
            }
            set
            {
                updatePath = value;
            }
        }

        public static void AddSearchPath(string path)
        {
            RemoveSearchPath(path);
            searchPaths.Insert(0, path);
        }

        public static void AddSearchPath(string path, int k)
        {
            RemoveSearchPath(path);
            searchPaths.Insert(k, path);
        }

        public static bool HasSearchPath(string path)
        {
            return searchPaths.Contains(path);
        }

        public static string [] GetSearchPaths()
        {
            return searchPaths.ToArray();
        }

        public static void SetSearchPaths(string[] paths)
        {
            searchPaths.Clear();
            for (int i = 0; i < paths.Length; ++i)
            {
                searchPaths.Add(paths[i]);
            }
        }

        public static void RemoveSearchPath(string path)
        {
            if (path != DEFAULT_SEARCH_PATH)
            {
                searchPaths.Remove(path);
            }
        }

        public static void RemoveAllSearchPaths(string path)
        {
            searchPaths.Clear();
            searchPaths.Add(DEFAULT_SEARCH_PATH);
        }

        // get writable path for application
        public static string GetWritablePath()
        {
            return Application.persistentDataPath;
        }

        // Get file data, with search paths
        public static byte [] GetDataFromFile(string fpath)
        {
            return GetDataFromFile(fpath, 0, 0);
        }

        // Get file data, with search paths
        public static byte [] GetDataFromFile(string fpath, long readOffset, long readSize)
        {
#if PROFILE_FILE
            Profiler.BeginSample("FileUtils.GetDataFromFile");
#endif
            long bytesRead = 0;
            byte [] data = GetDataFromFile(fpath, readOffset, readSize, out bytesRead);

#if PROFILE_FILE
            Profiler.EndSample();
#endif
            return data;
        }

        public static byte [] GetDataFromFile(string fpath, long readOffset, long readSize, out long bytesRead)
        {
#if PROFILE_FILE
            Profiler.BeginSample("FileUtils.GetDataFromFile");
#endif
            byte[] data = null;
            var length = searchPaths.Count;
            for (var i = 0; i < length; i++)
            {
                var p = searchPaths[i];
                string path = p + fpath;
                long bread = 0;
                data = GetDataFromFileNoSearching(path, readOffset, readSize, out bread);
                if (data != null)
                {
                    bytesRead = bread;
#if PROFILE_FILE
                    Profiler.EndSample();
#endif
                    return data;
                }
            }

            if (data == null)
            {
                LogUtil.Error("GetDataFromFile: cannot find " + fpath);
            }

            bytesRead = 0;

#if PROFILE_FILE
            Profiler.EndSample();
#endif
            return data;
        }

        public static string GetStringFromFile(string fpath)
        {
            string data = null;

            var length = searchPaths.Count;
            for (var i = 0; i < length; i++)
            {
                var p = searchPaths[i];
                string path = p + fpath;
                data = GetStringFromFileNoSearching(path);
                if (data != null)
                {
                    break;
                }
            }

            if (data == null)
            {
                LogUtil.Error("GetStringFromFile: cannot find " + fpath);
            }

            return data;
        }

        // no searching of paths, use the provided path as is
        // This method searches persistent data path first
        // then resolve to streaming assets path
        // in the end raw data path
        public static byte [] GetDataFromFileNoSearching(string path, long readOffset = 0, long readSize = 0)
        {
#if PROFILE_FILE
            Profiler.BeginSample("FileUtils.GetDataFromFileNoSearching");
#endif
            long bytesRead = 0;
            byte [] data = GetDataFromFileNoSearching(path, readOffset, readSize, out bytesRead);

#if PROFILE_FILE
            Profiler.EndSample();
#endif
            return data;
        }

        public static byte [] GetDataFromFileNoSearching(string path, long readOffset, long readSize, out long bytesRead)
        {
#if PROFILE_FILE
            Profiler.BeginSample("FileUtils.GetDataFromFileNoSearching");
#endif
            byte[] data = null;
            long bread = 0;

            // 1. check persistent path
            if (IsFileExistsInPersistentData(path))
            {
                data = GetDataFromPersistentData(path, readOffset, readSize, out bread);
                // LogUtil.Debug("GetDataFromFileNoSearching: found in persistentData");
            }
            // 2. check streaming assets path
            else if (IsFileExistsInStreamingAssets(path))
            {
                data = GetDataFromStreamingAssets(path, readOffset, readSize, out bread);
                // LogUtil.Debug("GetDataFromFileNoSearching: found in streamingAssets");
            }
            // 3. check raw file path
            else if (IsFileExistsInRawPath(path))
            {
                data = GetDataFromRawPath(path, readOffset, readSize, out bread);
                // LogUtil.Debug("GetDataFromFileNoSearching: found in rawPath");
            }
            else
            {
                bread = 0;
            }

            // LogUtil.Debug("GetDataFromFileNoSearching: " + path + " " + ((data != null) ? data.Length.ToString() : "empty"));
            bytesRead = bread;

#if PROFILE_FILE
            Profiler.EndSample();
#endif
            return data;
        }

        public static string GetStringFromFileNoSearching(string path)
        {
            string data = null;

            // 1. check persistent path
            if (IsFileExistsInPersistentData(path))
            {
                data = GetStringFromPersistentData(path);
                // LogUtil.Debug("GetStringFromFileNoSearching: found in persistentData");
            }
            // 2. check streaming assets path
            else if (IsFileExistsInStreamingAssets(path))
            {
                data = GetStringFromStreamingAssets(path);
                // LogUtil.Debug("GetStringFromFileNoSearching: found in streamingAssets");
            }
            // 3. check raw file path
            else if (IsFileExistsInRawPath(path))
            {
                data = GetStringFromRawPath(path);
                // LogUtil.Debug("GetStringFromFileNoSearching: found in rawPath");
            }

            // LogUtil.Debug("GetStringFromFileNoSearching: " + path + " " + ((data != null) ? data.Length.ToString() : "empty"));
            return data;
        }

        public static bool IsFileExists(string fpath)
        {
#if PROFILE_FILE
            Profiler.BeginSample("FileUtils.IsFileExists");
#endif
            var length = searchPaths.Count;
            for (var i = 0; i < length; i++)
            {
                var p = searchPaths[i];
                string path = p + fpath;
                // LogUtil.Debug("IsFileExists: trying path " + path);
                if (IsFileExistsNoSearching(path))
                {
#if PROFILE_FILE
            Profiler.EndSample();
#endif
                    return true;
                }
            }

#if PROFILE_FILE
            Profiler.EndSample();
#endif
            return false;
        }

        public static bool IsFileExistsNoSearching(string path)
        {
#if PROFILE_FILE
            Profiler.BeginSample("FileUtils.IsFileExistsNoSearching");
#endif
            // 1. check persistent path
            if (IsFileExistsInPersistentData(path))
            {
#if PROFILE_FILE
            Profiler.EndSample();
#endif
                return true;
            }
            // 2. check streaming assets path
            else if (IsFileExistsInStreamingAssets(path))
            {
#if PROFILE_FILE
            Profiler.EndSample();
#endif
                return true;
            }
            // 3. check raw file path
            else if (IsFileExistsInRawPath(path))
            {
#if PROFILE_FILE
            Profiler.EndSample();
#endif
                return true;
            }

#if PROFILE_FILE
            Profiler.EndSample();
#endif
            return false;
        }

        public static bool IsFileExistsNoSearching(string path, out string actualPath)
        {
#if PROFILE_FILE
            Profiler.BeginSample("FileUtils.IsFileExistsNoSearching");
#endif
            // 1. check persistent path
            if (IsFileExistsInPersistentData(path, out actualPath))
            {
#if PROFILE_FILE
            Profiler.EndSample();
#endif
                return true;
            }
            // 2. check streaming assets path
            else if (IsFileExistsInStreamingAssets(path, out actualPath))
            {
#if PROFILE_FILE
            Profiler.EndSample();
#endif
                return true;
            }
            // 3. check raw file path
            else if (IsFileExistsInRawPath(path, out actualPath))
            {
#if PROFILE_FILE
            Profiler.EndSample();
#endif
                return true;
            }

#if PROFILE_FILE
            Profiler.EndSample();
#endif
            return false;
        }

        public static string GetFullPathOfFile(string fpath)
        {
#if PROFILE_FILE
            Profiler.BeginSample("FileUtils.GetFullPathOfFile");
#endif
            var length = searchPaths.Count;
            for (var i = 0; i < length; i++)
            {
                var p = searchPaths[i];
                string path = p + fpath;
                // LogUtil.Debug("GetFullPathOfFile: trying path " + path);
                string actualPath = null;
                if (IsFileExistsNoSearching(path, out actualPath))
                {
#if PROFILE_FILE
                    Profiler.EndSample();
#endif
                    return actualPath;
                }
            }

#if PROFILE_FILE
            Profiler.EndSample();
#endif
            return null;
        }

        ////

        public static bool IsFileExistsInPersistentData(string path)
        {
#if PROFILE_FILE
            Profiler.BeginSample("FileUtils.IsFileExistsInPersistentData");
#endif
            var persistPath = Application.persistentDataPath + "/" + path;
            bool res = File.Exists(persistPath);

#if PROFILE_FILE
            Profiler.EndSample();
#endif
            return res;
        }

        public static bool IsFileExistsInPersistentData(string path, out string actualPath)
        {
#if PROFILE_FILE
            Profiler.BeginSample("FileUtils.IsFileExistsInPersistentData");
#endif
            var persistPath = Application.persistentDataPath + "/" + path;
            actualPath = persistPath;
            bool res = File.Exists(persistPath);

#if PROFILE_FILE
            Profiler.EndSample();
#endif
            return res;
        }

        public static byte [] GetDataFromPersistentData(string path, long readOffset = 0, long readSize = 0)
        {
            long bytesRead = 0;
            return GetDataFromPersistentData(path, readOffset, readSize, out bytesRead);
        }

        public static byte[] GetDataFromPersistentData(string path, long readOffset, long readSize, out long bytesRead)
        {
            var persistPath = Application.persistentDataPath + "/" + path;
            long bread = 0;

            if (File.Exists(persistPath))
            {
                byte[] data = ReadBytesFromFile(persistPath, readOffset, readSize, out bread);
                bytesRead = bread;
                return data;
            }

            bytesRead = 0;
            return null;
        }

        public static string GetStringFromPersistentData(string path)
        {
            string data = null;
            var persistPath = Application.persistentDataPath + "/" + path;

            if (File.Exists(persistPath))
            {
                data = File.ReadAllText(persistPath);
                return data;
            }

            return null;
        }

        public static bool IsFileExistsInStreamingAssets(string path)
        {
#if PROFILE_FILE
            Profiler.BeginSample("FileUtils.IsFileExistsInStreamingAssets");
#endif

#if UNITY_ANDROID && ! UNITY_EDITOR
            bool res = FileUtilsAndroid.IsFileExistsInAppJar(path);
#else
            var streamingPath = Application.streamingAssetsPath + "/" + path;
            bool res = File.Exists(streamingPath);
#endif

#if PROFILE_FILE
            Profiler.EndSample();
#endif
            return res;
        }

        public static bool IsFileExistsInStreamingAssets(string path, out string actualPath)
        {
#if PROFILE_FILE
            Profiler.BeginSample("FileUtils.IsFileExistsInStreamingAssets");
#endif

            var streamingPath = Application.streamingAssetsPath + "/" + path;
            actualPath = streamingPath;
#if UNITY_ANDROID && ! UNITY_EDITOR
            bool res = FileUtilsAndroid.IsFileExistsInAppJar(path);
#else
            bool res = File.Exists(streamingPath);
#endif

#if PROFILE_FILE
            Profiler.EndSample();
#endif
            return res;
        }

        public static byte [] GetDataFromStreamingAssets(string path, long readOffset = 0, long readSize = 0)
        {
            long bytesRead = 0;
            return GetDataFromStreamingAssets(path, readOffset, readSize, out bytesRead);
        }

        public static byte [] GetDataFromStreamingAssets(string path, long readOffset, long readSize, out long bytesRead)
        {
            byte[] data = null;
            long bread = 0;

#if UNITY_ANDROID && ! UNITY_EDITOR
            // 1 for android, read streaming assets from android jar
            data = FileUtilsAndroid.ReadDataFromAppJar(path, readOffset, readSize, out bread);
            bytesRead = bread;
#else
            // 2 for other devices, read streaming assets from filesystem
            var streamingPath = Application.streamingAssetsPath + "/" + path;
            if (File.Exists(streamingPath))
            {
                data = ReadBytesFromFile(streamingPath, readOffset, readSize, out bread);
                bytesRead = bread;
            }
            else
            {
                //LogUtil.Debug("GetDataFromStreamingAssets: cannot find " + path);
                bytesRead = 0;
            }
#endif

            return data;
        }

        public static string GetStringFromStreamingAssets(string path)
        {
            string data = null;

#if UNITY_ANDROID && ! UNITY_EDITOR
            // 1 for android, read streaming assets from android jar
            long bytesRead = 0;
            byte [] bytes = FileUtilsAndroid.ReadDataFromAppJar(path, 0, 0, out bytesRead);
            if (bytes != null)
            {
                data = System.Text.Encoding.UTF8.GetString(bytes);
            }
#else
            // 2 for other devices, read streaming assets from filesystem
            var streamingPath = Application.streamingAssetsPath + "/" + path;
            if (File.Exists(streamingPath))
            {
                data = File.ReadAllText(streamingPath);
            }
            else
            {
                //LogUtil.Debug("GetStringFromStreamingAssets: cannot find " + path);
            }
#endif

            return data;
        }

        public static bool IsFileExistsInRawPath(string path)
        {
#if PROFILE_FILE
            Profiler.BeginSample("FileUtils.IsFileExistsInRawPath");
#endif
            bool res = File.Exists(path);

#if PROFILE_FILE
            Profiler.EndSample();
#endif
            return res;
        }

        public static bool IsFileExistsInRawPath(string path, out string actualPath)
        {
#if PROFILE_FILE
            Profiler.BeginSample("FileUtils.IsFileExistsInRawPath");
#endif
            actualPath = path;
            bool res = File.Exists(path);

#if PROFILE_FILE
            Profiler.EndSample();
#endif
            return res;
        }

        public static byte [] GetDataFromRawPath(string path, long readOffset = 0, long readSize = 0)
        {
            long bytesRead = 0;
            return GetDataFromRawPath(path, readOffset, readSize, out bytesRead);
        }

        public static byte [] GetDataFromRawPath(string path, long readOffset, long readSize, out long bytesRead)
        {
            // read from file system
            if (File.Exists(path))
            {
                long bread = 0;
                byte[] data = ReadBytesFromFile(path, readOffset, readSize, out bread);
                bytesRead = bread;
                return data;
            }
            else
            {
                //LogUtil.Debug("GetDataFromRawPath: cannot find " + path);
                bytesRead = 0;
                return null;
            }
        }

        public static string GetStringFromRawPath(string path)
        {
            // read from file system
            if (File.Exists(path))
            {
                return File.ReadAllText(path);
            }
            else
            {
                //LogUtil.Debug("GetStringFromRawPath: cannot find " + path);
                return null;
            }
        }

        public static string GetStringFromRawPathZip(string path)
        {
            // read from file system
            if (File.Exists(path))
            {
                throw new Exception("not implemented yet");
            }
            else
            {
                //LogUtil.Debug("GetStringFromRawPathZip: cannot find " + path);
                return null;
            }
        }

        private static byte [] ReadBytesFromFile(string path, long readOffset, long readSize, out long bytesRead)
        {
            byte[] data = null;
            if (readOffset == 0 && readSize <= 0)
            {
                data = File.ReadAllBytes(path);
                bytesRead = readSize;
            }
            else
            {
                using (FileStream file = new FileStream(path,
                                             FileMode.Open, FileAccess.Read))
                {
                    if (readOffset > 0)
                    {
                        file.Seek((long)readOffset, SeekOrigin.Begin);
                    }

                    if (readSize <= 0)
                    {
                        readSize = (long)file.Length;
                    }

                    data = new byte[readSize];
                    int n = file.Read(data, 0, (int)readSize);
                    if (n > 0)
                    {
                        bytesRead = (long)n;
                    }
                    else
                    {
                        bytesRead = 0;
                    }
                }
            }
            return data;
        }

        // Get file data, with search paths
        public static WWW GetDataFromFileAsync(string fpath)
        {
            WWW www = null;
            var length = searchPaths.Count;
            for (var i = 0; i < length; i++)
            {
                var p = searchPaths[i];
                string path = p + fpath;
                // LogUtil.Debug("GetDataFromFileAsync: trying path " + path);
                www = GetDataFromFileNoSearchingAsync(path);
                if (www != null)
                    break;
            }

            return www;
        }

        // no searching of paths, use the provided path as is
        // This method searches persistent data path first
        // then resolve to streaming assets path
        // in the end raw data path
        public static WWW GetDataFromFileNoSearchingAsync(string path)
        {
            WWW data = null;

            // 1. check persistent path
            if (IsFileExistsInPersistentData(path))
            {
                data = GetDataFromPersistentDataAsync(path);
				Debug.Log ("Get File from persist data:"+path);
                // LogUtil.Debug("GetDataFromFileNoSearching: found in persistentData");
            }
            // 2. check streaming assets path
            else if (IsFileExistsInStreamingAssets(path))
            {
                data = GetDataFromStreamingAssetsAsync(path);
				Debug.Log ("Get File from stream asset:"+path);
                // LogUtil.Debug("GetDataFromFileNoSearching: found in streamingAssets");
            }
            // 3. check raw file path
            else if (IsFileExistsInRawPath(path))
            {
                data = GetDataFromRawPathAsync(path);
				Debug.Log ("Get File from rawo path:"+path);
            }

            return data;

        }

        public static WWW GetDataFromPersistentDataAsync(string path)
        {
            var persistPath = Application.persistentDataPath + "/" + path;

            if (File.Exists(persistPath))
            {
                var www = new WWW("file://" + persistPath);
                return www;
            }

            return null;
        }


        public static WWW GetDataFromStreamingAssetsAsync(string path)
        {
#if UNITY_ANDROID && ! UNITY_EDITOR
            var streamingPath = Application.streamingAssetsPath + "/" + path;
            var www =  new WWW(streamingPath);
            return www;
#else
            var streamingPath = Application.streamingAssetsPath + "/" + path;
            if (File.Exists(streamingPath))
            {
                var www = new WWW("file://" + streamingPath);
                return www;
            }
#endif

            return null;
        }


        public static WWW GetDataFromRawPathAsync(string path)
        {
            // read from file system
            if (File.Exists(path))
            {
                var www = new WWW("file://" + path);
                return www;
            }

            return null;
        }

        // Prepare the path of asset bundle file in file system
        // Android just needs to modify the path a bit when loading bundle from streaming assets
        public static string PrepareBundleFile(string path)
        {
#if PROFILE_FILE
            Profiler.BeginSample("FileUtils.PrepareBundleFile");
#endif
            var length = searchPaths.Count;
            for (int i = 0; i < length; ++i)
            {
                string p = searchPaths[i];
                string fullpath = p + path;
                string actualPath = null;

#if UNITY_ANDROID && ! UNITY_EDITOR
                // For android, copy bundle from streaming assets to update path
                if (IsFileExistsInPersistentData(fullpath, out actualPath))
                {
                    LogUtil.Debug("PrepareBundleFile: found in persistent path " + fullpath);
#if PROFILE_FILE
                    Profiler.EndSample();
#endif
                    return actualPath;
                }
                else if (IsFileExistsInStreamingAssets(fullpath))
                {
                    string fixedPath = Application.dataPath + "!assets/" + fullpath;
                    LogUtil.Debug("PrepareBundleFile: found in streaming assets " + fullpath + " fixed: " + fixedPath);
#if PROFILE_FILE
                    Profiler.EndSample();
#endif
                    return fixedPath;
                }
                else if (IsFileExistsInRawPath(fullpath, out actualPath))
                {
                    LogUtil.Debug("PrepareBundleFile: found in raw path " + fullpath);
#if PROFILE_FILE
                    Profiler.EndSample();
#endif
                    return actualPath;
                }
#else
                if (IsFileExistsNoSearching(fullpath, out actualPath))
                {
#if PROFILE_FILE
                    Profiler.EndSample();
#endif
                    return actualPath;
                }

#endif // UNITY_ANDROID
            }

            throw new Exception("PrepareBundleFile: cannot find file " + path);
        }

        public static bool CopyFile(string srcfile, string dstfile, bool overwrite)
        {
#if UNITY_ANDROID && ! UNITY_EDITOR
            if (FileUtilsAndroid.IsFileExistsInAppJar(srcfile))
            {
                return FileUtilsAndroid.CopyFileFromAppJar(srcfile, dstfile, overwrite);
            }
            else
            {
                string fullpath = GetFullPathOfFile(srcfile);
                File.Copy(fullpath, dstfile, overwrite);
                return true;
            }
#else
            string fullpath = GetFullPathOfFile(srcfile);
            File.Copy(fullpath, dstfile, overwrite);
            return true;
#endif
        }

        public static bool DeleteFile(string file)
        {
            string fullpath = GetFullPathOfFile(file);
            File.Delete(fullpath);
            return true;
        }

        public void ExtractZipFile(string archiveFilenameIn, string password, string entryFile, string outFolder) {
            ZipFile zf = null;
            try {
                FileStream fs = File.OpenRead(archiveFilenameIn);
                zf = new ZipFile(fs);
                if (!String.IsNullOrEmpty(password)) {
                    zf.Password = password;		// AES encrypted entries are handled automatically
                }
                foreach (ZipEntry zipEntry in zf) {
                    if (!zipEntry.IsFile) {
                        continue;			// Ignore directories
                    }
                    String entryFileName = zipEntry.Name;
                    // to remove the folder from the entry:- entryFileName = Path.GetFileName(entryFileName);
                    // Optionally match entrynames against a selection list here to skip as desired.
                    // The unpacked length is available in the zipEntry.Size property.

                    if (!String.IsNullOrEmpty(entryFile) && entryFileName != entryFile) {
                        continue; // only extract specified file
                    }

                    byte[] buffer = new byte[4096];		// 4K is optimum
                    Stream zipStream = zf.GetInputStream(zipEntry);

                    // Manipulate the output filename here as desired.
                    String fullZipToPath = Path.Combine(outFolder, entryFileName);
                    string directoryName = Path.GetDirectoryName(fullZipToPath);
                    if (directoryName.Length > 0)
                        Directory.CreateDirectory(directoryName);

                    // Unzip file in buffered chunks. This is just as fast as unpacking to a buffer the full size
                    // of the file, but does not waste memory.
                    // The "using" will close the stream even if an exception occurs.
                    using (FileStream streamWriter = File.Create(fullZipToPath)) {
                        StreamUtils.Copy(zipStream, streamWriter, buffer);
                    }
                }
            } finally {
                if (zf != null) {
                    zf.IsStreamOwner = true; // Makes close also shut the underlying stream
                    zf.Close(); // Ensure we release resources
                }
            }
        }
    }
}
