//
// SkillScanner.cs
//
// Author:
//       duwenjie
//

//
// ------------------------------------------------------------------------------
//  <autogenerated>
//      This code was generated by a tool.
//      Mono Runtime Version: 4.0.30319.1
//
//      Changes to this file may cause incorrect behavior and will be lost if
//      the code is regenerated.
//  </autogenerated>
// ------------------------------------------------------------------------------

using UnityEngine;
using UnityEditor;
using System.Collections.Generic;
using System.IO;
using System.Security.Cryptography;
using System;
using LBoot;
using System.Linq;
using System.Text.RegularExpressions;
using LitJson;
using System.Text;

public class CharacterScanner
{
    CharacterJsonWriter writer = null;

    public CharacterScanner(CharacterJsonWriter writer)
    {
        if (writer == null)
        {
            this.writer = new CharacterJsonWriter();
        }
        else
        {
            this.writer = writer;
        }
    }

    public void ScanPrefab(string name, GameObject prefab)
    {
        var go = GameObject.Instantiate(prefab);

        var animator = go.GetComponent<Animator>();
        if (animator == null)
            return;

        var controller = animator.runtimeAnimatorController;
        if (controller == null)
            return;

        var editorAnimatorController = controller as UnityEditor.Animations.AnimatorController;
        if (editorAnimatorController == null)
            return;

        var layer = editorAnimatorController.layers[0];
        if (layer == null)
            return;

        var sm = layer.stateMachine;
        var colliders = GetColliders(go);

        var allMaxAttackBounds = new Bounds();
        var allMaxRecvBounds = new Bounds();

        this.writer.WritePropertyName(name);
        this.writer.WriteObjectStart();

        foreach (var state in sm.states)
        {
            if (state.state.motion != null)
            {
                if (!state.state.motion.name.Contains("_atk"))
                    continue;
                var stateName = state.state.name;
                var animName = state.state.motion.name;
                var clip = state.state.motion as AnimationClip;
                this.writer.WriteAnimation(stateName, animName, clip, go, colliders, ref allMaxAttackBounds, ref allMaxRecvBounds);
            }
            else
            {
                LogUtil.Debug(name + " state " + state.state.name + " motion is null");
            }
        }

        this.writer.WriteAllMaxAnimation(allMaxAttackBounds, allMaxRecvBounds);

        this.writer.WriteObjectEnd();
        GameObject.DestroyImmediate(go);
    }

    public List<ColliderInfo> GetColliders(GameObject go)
    {
        var colliders = new List<ColliderInfo>();
        for (int i = 1; i <= 10; i++)
        {
            var name = "AttackCollider_" + i;
            var transform = go.transform.Find(name);
            if (transform == null)
                return null;
            var collider = transform.gameObject.GetComponent<BoxCollider>();
            if (collider == null)
                return null;
            var info = new ColliderInfo(name, collider);
            info.index = i - 1;
            colliders.Add(info);
        }

        // var recvName = "RecvCollider";
        // var recvTransform = go.transform.Find(recvName);
        // if (recvTransform == null)
        //     return null;
        // var recvCollider = recvTransform.gameObject.GetComponent<BoxCollider>();
        // if (recvCollider == null)
        //     return null;
        // var recvInfo = new ColliderInfo(recvName, recvCollider);
        // colliders.Add(recvInfo);

        return colliders;
    }
}

public class ColliderInfo
{
    public string colliderName;
    public BoxCollider collider;
    public int index = 0;

    public ColliderInfo(string name, BoxCollider collider)
    {
        this.colliderName = name;
        this.collider = collider;
    }
}

public class CharacterJsonWriter : ScannerJsonWriter
{

    public void WriteAllMaxAnimation(Bounds allMaxAttackBounds, Bounds allMaxRecvBounds)
    {
        this.writer.WritePropertyName("_all_max");
        this.writer.WriteObjectStart();
        this.WriteBounds("max_atk_collider", allMaxAttackBounds);
        this.WriteBounds("max_recv_collider", allMaxRecvBounds);
        this.writer.WriteObjectEnd();
    }

    public void WriteAnimation(string stateName, string animName, AnimationClip clip, GameObject go,
                            List<ColliderInfo> colliders, ref Bounds allMaxAttackBounds, ref Bounds allMaxRecvBounds)
    {
        if (colliders == null)
            return;

        this.writer.WritePropertyName(stateName);
        this.writer.WriteObjectStart();

        this.writer.WritePropertyName("length");
        this.writer.Write(clip.length);

        this.WriteColliders(clip, go, colliders, ref allMaxAttackBounds, ref allMaxRecvBounds);

        this.writer.WriteObjectEnd();
    }

    public void WriteColliders(AnimationClip clip, GameObject go, List<ColliderInfo> colliders,
                            ref Bounds allMaxAttackBounds, ref Bounds allMaxRecvBounds)
    {
        this.writer.WritePropertyName("atk_timeline");
        this.writer.WriteArrayStart();

        var iFrame = 0;
        var step = 1f / clip.frameRate;
        var atkBoxBounds = new List<Bounds>();
        var atkBoxTimelines = new List<List<Int32>>();
        var maxAttackBounds = new Bounds();
        var maxRecvBounds = new Bounds();
        var atkColliderCount = colliders.Count;

        for (var j = 0; j < atkColliderCount; ++j)
        {
            atkBoxBounds.Add(new Bounds());
            atkBoxTimelines.Add(new List<Int32>());
        }

        for (float time = 0f; time <= clip.length; time = time + step)
        {
            clip.SampleAnimation(go, time);

            var hasActiveAttackCollider = false;
            foreach (var info in colliders)
            {
                var collider = info.collider;
                if (collider.enabled)
                {
                    var bounds = new Bounds(collider.transform.position, collider.size);
                    if (info.colliderName.StartsWith("Attack"))
                    {
                        hasActiveAttackCollider = true;

                        var box = atkBoxBounds[info.index];
                        box.Encapsulate(bounds);
                        atkBoxBounds[info.index] = box;
                        atkBoxTimelines[info.index].Add(iFrame);

                        maxAttackBounds.Encapsulate(bounds);
                        allMaxAttackBounds.Encapsulate(bounds);

                        this.writer.Write(iFrame);

//						LogUtil.Debug("attack=" + bounds.ToString());
//						LogUtil.Debug("box=" + box.ToString());
//						LogUtil.Debug("max=" + maxAttackBounds.ToString());
//						LogUtil.Debug("allMax=" + allMaxAttackBounds.ToString());
                    }
                    else
                    {
                        maxRecvBounds.Encapsulate(bounds);
                        allMaxRecvBounds.Encapsulate(bounds);
                    }
                }
            }

//			this.writer.Write(hasActiveAttackCollider);
            iFrame++;
        }

        this.writer.WriteArrayEnd();

        this.WriteBounds("max_atk_collider", maxAttackBounds);
        this.WriteBounds("max_recv_collider", maxRecvBounds);

        this.writer.WritePropertyName("atk_boxes");
        this.writer.WriteArrayStart();
        for (var j = 0; j < atkColliderCount; ++j)
        {
            if (atkBoxBounds[j].size.magnitude > 0)
            {
                this.writer.WriteObjectStart();
                this.WritePropertyName("timeline");
                this.WriteArrayStart();
                foreach (var k in atkBoxTimelines[j])
                {
                    this.writer.Write(k);
                }
                this.WriteArrayEnd();
                this.WriteBounds("max_collider", atkBoxBounds[j]);
                this.writer.WriteObjectEnd();
            }
            else
            {
                this.writer.Write(null);
            }
        }
        this.writer.WriteArrayEnd();
    }

    public void WriteCollider(string name, Collider collider)
    {
        this.writer.WritePropertyName(name);
        this.writer.WriteObjectStart();
        this.writer.WritePropertyName("center");
        this.WriteVector3(collider.bounds.center);
        this.writer.WritePropertyName("size");
        this.WriteVector3(collider.bounds.size);
        this.writer.WriteObjectEnd();
    }

    public void WriteBounds(string name, Bounds bounds)
    {
        this.writer.WritePropertyName(name);
        this.writer.WriteObjectStart();
//		this.writer.WritePropertyName("center");
//		this.WriteVector3(bounds.center);
//		this.writer.WritePropertyName("size");
//		this.WriteVector3(bounds.size);
        this.writer.WritePropertyName("min");
        this.WriteVector3(bounds.center - bounds.size / 2);
        this.writer.WritePropertyName("max");
        this.WriteVector3(bounds.center + bounds.size / 2);
        this.writer.WriteObjectEnd();
    }
}
