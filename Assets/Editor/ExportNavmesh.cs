//
// ExportNavmesh.cs
//
// Author:
//       duwenjie <duwenjie>
//
//  All Rights Reserved
//
// ------------------------------------------------------------------------------
//  <autogenerated>
//      This code was generated by a tool.
//      Mono Runtime Version: 4.0.30319.1
// 
//      Changes to this file may cause incorrect behavior and will be lost if 
//      the code is regenerated.
//  </autogenerated>
// ------------------------------------------------------------------------------
using System.IO;
using System.Text;
using UnityEditor;
using UnityEngine;
using System.Collections;

public class ExportNavMeshToObj : MonoBehaviour {
	
	[MenuItem("Tools/Custom/Export NavMesh to mesh")]
	static void Export() {
		UnityEngine.AI.NavMeshTriangulation triangulatedNavMesh = UnityEngine.AI.NavMesh.CalculateTriangulation();
		Mesh mesh = new Mesh();
		mesh.name = "ExportedNavMesh";
		mesh.vertices = triangulatedNavMesh.vertices;
		int[] areas = triangulatedNavMesh.areas;
		mesh.triangles = triangulatedNavMesh.indices;
		string filename = Application.dataPath +"/" + Path.GetFileNameWithoutExtension(EditorApplication.currentScene) + ".obj";
		MeshToFile(mesh, areas, filename);
		print("NavMesh exported as '" + filename + "'");
		AssetDatabase.Refresh();
	}
	
	//merge same vertices
	static void PreProcMesh(Mesh mesh, out Hashtable ht, out Vector3[] vertices)
	{
		ht = new Hashtable();
		ArrayList al = new ArrayList();
		int nV = mesh.vertices.GetLength (0);
		for (int j = 0; j < nV; j++) {
			Vector3 v = mesh.vertices[j];
			if( ht.Contains(string.Format("{0}", j)) )
			{
				print ("add remove:"+j);
				continue;
			}
			else
			{
				print ("add:"+j);
				al.Add(v);
				ht.Add(string.Format("{0}", j), al.Count-1);
				for(int i = j+1; i<nV; i++)
				{
					Vector3 v1 = mesh.vertices[i];
					if(Mathf.Approximately(v.x, v1.x) && Mathf.Approximately(v.y, v1.y) && Mathf.Approximately(v.z, v1.z))
					{
						print ("add:"+i);
						ht.Add(string.Format("{0}", i), al.Count-1);
					}
				}
			}
		}
		
		vertices = (Vector3[])al.ToArray (typeof(Vector3));
	}
	
	static void CalcBounds(Mesh mesh, ref Vector3 min, ref Vector3 max)
	{
		int nV = mesh.vertices.GetLength (0);
		for (int j = 0; j < nV; j++) {
			Vector3 v = mesh.vertices[j];
			if (j == 0 )
			{
				min.x = v.x;
				min.y = v.y;
				min.z = v.z;
				
				max.x = v.x;
				max.y = v.y;
				max.z = v.z;
			}
			else
			{
				if(min.x > v.x) min.x = v.x;
				if(min.y > v.y) min.y = v.y;
				if(min.z > v.z) min.z = v.z;
				
				if(max.x < v.x) max.x = v.x;
				if(max.y < v.y) max.y = v.y;
				if(max.z < v.z) max.z = v.z;
			}
		}
	}
	
	public const ushort nvp = 6;
	public const ushort RC_MESH_NULL_IDX = 0Xffff;
	public const int ns = 5;
	
	static string MeshToString(Mesh mesh, int[] areas) {
		StringBuilder sb = new StringBuilder();
		//counters
		int nT = 0;
		for (int j = 0; j < mesh.subMeshCount; j++) {
			int[] triangles = mesh.GetTriangles(j);
			nT += triangles.Length/3;
		}
		
		//merge vertices
		Vector3 [] vertices;
		Hashtable ht;
		PreProcMesh (mesh, out ht, out vertices);
		int nV = vertices.GetLength (0);
		sb.Append(string.Format("{0} {1}\n", nV, nT));
		
		//bounds
		Vector3 min = new Vector3();
		Vector3 max = new Vector3();
		CalcBounds(mesh, ref min, ref max);
		print ("min: x"+min.x+" y:"+min.y+" z:"+min.z);
		print ("max: x"+max.x+" y:"+max.y+" z:"+max.z);
		sb.Append(string.Format("{0} {1} {2} {3} {4} {5}\n", 0, 0, 0, (max.x-min.x)*ns, (max.y-min.y)*ns, (max.z-min.z)*ns));
		
		
		//vertices
		foreach (Vector3 v in vertices) {
			sb.Append(string.Format("v {0} {1} {2}\n",(v.x-min.x)*ns, (v.y-min.y)*ns, (v.z-min.z)*ns));
		}
		
		//remap triangles 
		const int un = nvp * 2;
		int len = nT * un;
		ushort[] tris = new ushort[len];
		for(int i = 0; i < len; i++)
			tris[i] = RC_MESH_NULL_IDX;
		
		for (int j = 0; j < mesh.subMeshCount; j++) 
		{
			int[] triangles = mesh.GetTriangles(j);
			for (int i=0;i<triangles.Length;i+=3) 
			{
				int p1 = 0;
				int p2 = 0;
				int p3 = 0;
				int.TryParse(string.Format ("{0}", ht[string.Format("{0}", triangles[i])]), out p1);
				int.TryParse(string.Format ("{0}", ht[string.Format("{0}", triangles[i+1])]), out p2);
				int.TryParse(string.Format ("{0}", ht[string.Format("{0}", triangles[i+2])]), out p3);
				print (">>>>len:"+len+" i/3*un:"+(i/3*un));
				tris[i/3*un] = (ushort)p1;
				tris[i/3*un+1] = (ushort)p2;
				tris[i/3*un+2] = (ushort)p3;
			}
		}
		
		//calc neibours
		BuildAdjacency (nV, nT, ref tris);
		
		
		sb.Append ("\n");
		for (int i=0; i<tris.Length; i+=un) {
			sb.Append(string.Format("f {0} {1} {2} {3} {4} {5} {6} {7} {8} {9}\n", 
			                        tris[i], tris[i+1], tris[i+2],
			                        tris[i+nvp], tris[i+nvp+1], tris[i+nvp+2], tris[i+nvp+3], tris[i+nvp+4], tris[i+nvp+5],
			                        areas[i/un]));
		}
		
		return sb.ToString();
	}
	
	struct rcEdge{
		public ushort[] vert;
		public ushort[] polyEdge;
		public ushort[] poly;
	}
	
	static bool BuildAdjacency(int nverts, int npolys,  ref ushort[] tris)
	{
		int maxEdgeCount = npolys*nvp;
		ushort[] firstEdge = new ushort[nverts + maxEdgeCount];
		
		int edgeCount = 0;
		rcEdge[] edges = new rcEdge[maxEdgeCount];
		for (int i = 0; i < maxEdgeCount; i ++) {
			edges[i] = new rcEdge();
			edges[i].vert = new ushort[2]{0,0};
			edges[i].polyEdge = new ushort[2]{0,0};
			edges[i].poly = new ushort[2]{0,0};
		}
		
		for (int i = 0; i < nverts; i++)
			firstEdge[i] = RC_MESH_NULL_IDX;
		
		const int un = nvp*2;
		for (int i = 0; i < npolys; ++i)
		{
			for (int j = 0; j < nvp; ++j)
			{
				if (tris[i*un+j] == RC_MESH_NULL_IDX) break;
				ushort v0 = tris[i*un+j];
				ushort v1 = ((j+1 >= nvp) || (tris[i*un+j+1] == RC_MESH_NULL_IDX)) ? tris[i*un] : tris[i*un+j+1];
				if (v0 < v1)
				{
					rcEdge edge = edges[edgeCount];
					edge.vert[0] = v0;
					edge.vert[1] = v1;
					edge.poly[0] = (ushort)i;
					edge.polyEdge[0] = (ushort)j;
					edge.poly[1] = (ushort)i;
					edge.polyEdge[1] = 0;
					// Insert edge
					firstEdge[nverts+edgeCount] = firstEdge[v0];
					firstEdge[v0] = (ushort)edgeCount;
					edgeCount++;
				}
			}
		}
		
		for (int i = 0; i < npolys; ++i)
		{
			for (int j = 0; j < nvp; ++j)
			{
				if (tris[i*un+j] == RC_MESH_NULL_IDX) break;
				ushort v0 = tris[i*un+j];
				ushort v1 = ((j+1 >= nvp) || (tris[i*un+j+1] == RC_MESH_NULL_IDX)) ? tris[i*un] : tris[i*un+j+1];
				if (v0 > v1)
				{
					for (ushort e = firstEdge[v1]; e != RC_MESH_NULL_IDX; e = firstEdge[nverts+e])
					{
						rcEdge edge = edges[e];
						if (edge.vert[1] == v0 && edge.poly[0] == edge.poly[1])
						{
							edge.poly[1] = (ushort)i;
							edge.polyEdge[1] = (ushort)j;
							break;
						}
					}
				}
			}
		}
		
		// Store adjacency
		for (int i = 0; i < edgeCount; ++i)
		{
			rcEdge e = edges[i];
			if (e.poly[0] != e.poly[1])
			{
				tris[e.poly[0]*un + nvp + e.polyEdge[0]] = e.poly[1];
				tris[e.poly[1]*un + nvp + e.polyEdge[1]] = e.poly[0];
			}
		}
		
		return true;
	}
	
	static void MeshToFile(Mesh mesh, int[] areas, string filename) {
		using (StreamWriter sw = new StreamWriter(filename)) {
			sw.Write(MeshToString(mesh, areas));
		}
	}
}
